
<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="abcjs_basic_2.3-min.js" type="text/javascript"></script>
	<script src="parser.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.0/seedrandom.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>


	<script type="text/javascript">

    var staves = [new Object()];
    var OCTAVE = 12;
	var MEASURE_LENGTH_PADDING = 2;
    var seed;
    var timeNumerator = 4;
    var timeDenominator = 4;
    var clef = "treble";
    var minMeasures = 0;
    var maxMeasures = 0;
    var measures = 0;
    var absMinPitch = 0;
    var absMaxPitch = 127;
    var minPolyphony;
    var maxPolyphony;
    var possPolyphony = null;
    var lineLength = 25;
    var startKey = 'C';
    var noteLengths = ['q'];
    var noteLetters = ['A,,,,', 'B,,,,','C,,,', 'D,,,', 'E,,,', 'F,,,', 'G,,,', 'A,,,', 'B,,,','C,,', 'D,,', 'E,,', 'F,,', 'G,,', 'A,,', 'B,,','C,', 'D,', 'E,', 'F,', 'G,', 'A,', 'B,', 'C', 'D', 'E', 'F', 'G', 'A', 'B', 'c', 'd', 'e', 'f', 'g', 'a', 'b', "c'", "d'", "e'", "f'", "g'", "a'", "b'", "c''", "d'", "e''", "f'", "g''", "a''", "b''", "c'''"];

    var letterVals = {
        "C": 0,
        "D": 2,
        "E": 4,
        "F": 5,
        "G": 7,
        "A": 9,
        "B": 11
    };

    var notesSharps = ["C", "^C", 'D', '^D', 'E', "F", "^F", "G", "^G", "A", "^A", "B"];
    var notesFlats = ["C", "_D", 'D', '_E', 'E', "F", "_G", "G", "_A", "A", "_B", "B"];


    //var keys = ['A','B','C','D','E','F','G'];

    //returns a random number between 0 and bound.
    function randInt(bound) {
        return Math.floor(Math.random() * (bound));
    }

    //@pre: note is a string of the format "LETTER (A-G) + (#* OR b*) + NUMBER (0-8)," eg C#4 or D2.
    function sciToMidi(note){
        var letter = note.charAt(0).toUpperCase();
        var octave = parseInt(note.charAt(note.length-1));
        var symbols = note.substring(1, note.length-1);

        var midi = 0;
        midi = (octave + 1) * OCTAVE + letterVals[letter];

        //assumes that we have only sharps OR only flats in 'symbols' (never both sharps and flats).
        if (symbols.length > 0){

            //add 1 for every sharp
            if (symbols.charAt(0) == '#') {
                midi = midi + symbols.length;
            }

            //subtract 1 for every flat
            else if (symbols.charAt(0) == 'b'){
                midi = midi - symbols.length;
            }
        }
        return midi;
    }

    //converts midi value of note pitch (int from 0 to 127) to corresponding ABC representation
    function midiToAbc(midi){
        var abcString;
        if (randInt(2) == 0) {
            abcString = notesSharps[midi % 12];
        }
        else {
            abcString = notesFlats[midi%12];
        }
        var octave = Math.floor((midi-60)/12);

        var symbol;
        if (octave > 0){
            symbol = "'"; //higher than middle C octave
        }
        else {
            symbol = ","; //lower or equal to middle C octave
        }
        
        octave = Math.abs(octave);
        
        while (octave > 0){
            octave--;
            abcString = abcString + symbol;
        }

        return abcString;
    }

    //generates and renders piece based on current parameters
    function generate(){


        reset();

        //parse
        var parseSuccess = true;
        try {
            parse();
        }
        catch(err) {
            $("#error").html(err.name + ": " + err.message);
            console.log(err);
            parseSuccess = false;
        }

        //generate ABC string and render it
        if (parseSuccess){
            defaults();
            ABCJS.renderAbc('notation', genABC());
        }
    }

    //default values that depend on parsed values (eg default absRange depends on clef)
    function setup(){

    }

    function reset(){
        //clear out prev sheet music
        $("#notation").html("");

        //clear out any error messages
        $("#error").html("");

        staves = [];
    }

    //put this after parse and just check for null
    function defaults(){

        if (staves[0].clef == null){
            staves[0].clef = "treble";
        }

        if (staves[0].key == null){
            staves[0].key = "C";
        }

        if (staves[0].minMeasures == null){
            staves[0].minMeasures = 10;
            staves[0].maxMeasures = 20;
        }

        if (staves[0].absMinPitch == null){
            staves[0].absMinPitch = sciToMidi("G3");
            staves[0].absMaxPitch = sciToMidi("C6");
        }

        if (staves[0].absMinPitch == null && staves[0].possPolyphony == null){
            staves[0].minPolyphony = 1;
            staves[0].maxPolyphony = 3;
        }
    }

    //parses whatever's in the #input text area with parser.parse().  sets appropriate parameters based on data received from parsing.
    function parse(){
    	var data = parser.parse($('textarea#input').val());
    	
        for (var i = 0; i < data.length; i++){

            staves.push(new Object());

        	//number of measures.  either array (when user enters a min/max range) or an int.
            if (data[i].numMeasures != null){
                if (data[i].numMeasures.constructor === Array){
                   staves[i].minMeasures = data[i].numMeasures[0];
                   staves[i].maxMeasures = data[i].numMeasures[1];
                }
                else {
                    staves[i].minMeasures = data[i].numMeasures;
                    staves[i].maxMeasures = data[i].numMeasures;
                }
            }

            //starting key
            if (data[i].key != null){
                staves[i].startKey = data[i].key;
            }

            //seed
            if (data[0].seed != null){
                seed = data[0].seed;
            }
            else {
                //we "unseed" briefly to randomly generate a new seed not based on a previous one.
                Math.seedrandom(Date.now()%1000);
                var randSeed = Math.random().toString(36).substr(2, 5);
                seed = randSeed;
            }
            Math.seedrandom(seed);
            $("#seed").html(seed);

            //clef
            if (data[i].clef != null){
                staves[i].clef = data[i].clef;
            }

            //absolute min/max pitch
            if (data[i].absRange != null){
                staves[i].absMinPitch = data[i].absRange[0];
                staves[i].absMaxPitch = data[i].absRange[1];
            }

            //polyphony
            if (data[i].polyphony != null){
                if (data[i].polyphony.constructor === Array){
                    //int list
                    if (data[i].polyphony[0] == "list"){
                        data[i].polyphony.splice(0,1);
                        staves[i].possPolyphony = data[i].polyphony;
                        console.log(possPolyphony);
                    }
                    //int range
                    else {
                        staves[i].minPolyphony = data[i].polyphony[0];
                        staves[i].maxPolyphony = data[i].polyphony[1];
                    }
                }
                //single int
                else {
                    staves[i].minPolyphony = data[i].polyphony;
                    staves[i].maxPolyphony = data[i].polyphony;
                }
            }
        }
    }

    function genABC(){
        var genString ="M: " + timeNumerator + "/" + timeDenominator + "\n";
        genString = genString + "L: 1/4 \n"
        genString = genString + "K: " + staves[0].startKey + " " + staves[0].clef + "\n"

        measures = randInt(staves[0].maxMeasures - staves[0].minMeasures + 1) + staves[0].minMeasures;
        console.log(staves.length);
        for (var i = 1; i < staves.length; i++) {

            //if a clef isn't specified for this stave, use global clef
            var clef;
            if (staves[i].clef != null){
                clef = staves[i].clef;
            }
            else clef = staves[0].clef;
            genString = genString + "[V: " + i + " clef: " + clef + "] ";
            genString = genString + genStave(i) + "\n";
            console.log(genString);
        }

        genString.replace(/[\n\n]{2,}/g, "\n");

        return genString;
    }

    function genStave(stave){
        var genString = "";
        var curLineLength = 0; //current number of notes in line (to keep track of when to start new line)
        var m = measures;
        while (m > 0){
            var measure = genMeasure(stave);
            m--;
            genString = genString + measure.measureString;
            curLineLength += measure.numNotes;

            //start new line if we're past lineLength, but only if we have some measures left.
            if (curLineLength >= lineLength && m > 0){
                curLineLength = 0;
                genString = genString + "\n";
            }
        }
        return genString;
    }

    //returns an object that wraps two elements: measureString, numNotes
    function genMeasure(stave){

    	var measureString = "";
    	var n = 4;
    	var numNotes = 0;
    	while (n > 0){
    		n--;
    		measureString = measureString + " " + genRandomNote(stave, getPoly(stave));
    		numNotes++;  //increment numNotes every time we add a note.
    	}
    	measureString = measureString + " |";
    	numNotes += MEASURE_LENGTH_PADDING;
    	return {
    		measureString: measureString, 
    		numNotes: numNotes
    	}
    }

    //TODO: potential infinite loop if user enters SMALL abs pitch range and LARGE poly.
    //generates random note with 'poly' pitches, all within abs pitch range.
    function genRandomNote(stave, poly){
        var noteString = "[";

        //stores midi representation of notes
        var notes = [];

        var absMinPitch, absMaxPitch;
        if (staves[stave].absMinPitch != null){
            absMinPitch = staves[stave].absMinPitch;
        }
        else {
            absMinPitch = staves[0].absMinPitch;
        }
        if (staves[stave].absMaxPitch != null){
            absMaxPitch = staves[stave].absMaxPitch;
        }
        else {
            absMaxPitch = staves[0].absMaxPitch;
        }

        //add notes 'poly' times
        while (poly > 0){
            poly--;
            
            //loop until we find a note that isn't in note array yet
            var posNote = randInt(absMaxPitch - absMinPitch + 1) + absMinPitch;
            while (notes.indexOf(posNote) > -1){
                posNote = randInt(absMaxPitch - absMinPitch + 1) + absMinPitch;
            }
            notes[notes.length] = posNote;
        }

        //create string from midi notes in 'note' array
        for (var i = 0; i < notes.length; i++){
            noteString = noteString + midiToAbc(notes[i]);
        }
        noteString = noteString + "]";
        return noteString;
    }

    //returns a random possible poly amount (num of notes in chord)
    //order of precedence - stave poss, stave max/min, global poss, global max/min
    function getPoly(stave){

        if (staves[stave].possPolyphony != null){
            return staves[stave].possPolyphony[randInt(staves[stave].possPolyphony.length)];
        }
        else if (staves[stave].maxPolyphony != null){
            return randInt(staves[stave].maxPolyphony - staves[stave].minPolyphony + 1) + staves[stave].minPolyphony;
        }
        else if (staves[0].possPolyphony != null){
            return staves[0].possPolyphony[randInt(staves[0].possPolyphony.length)];
        }
        return randInt(staves[0].maxPolyphony - staves[0].minPolyphony + 1) + staves[0].minPolyphony;
    }

    </script>

    
    <a href="#" onclick="generate()" >GENERATE  </a>
    <p>Seed: <span id ="seed"></span> <br> <span id = "error"></span></p>


    <textarea id="input">measures: 10-20
clef: treble
key: C
absRange: G3-C6
polyphony: 1

Stave1{
polyphony: 1-3
}

Stave2{
clef: bass
absRange: G1-G3
}
</textarea>

    <div id="notation"></div>

</body>
</html>